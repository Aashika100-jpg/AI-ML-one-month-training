# -*- coding: utf-8 -*-
"""Handling missing record.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZsQqTz2mK_ntYp2d6Li0BRCr8Xe6TM9_
"""

#handling missing record
#Group by

import pandas as pd

df = df_requested_data
df.head()

import pandas as pd

# Create a dictionary with dummy data for the requested columns
data = {
    'id': [1, 2, 3, 4],
    'employee_id': ['EMP001', 'EMP002', 'EMP003', 'EMP004'],
    'name': ['Alice', 'Bob', 'Charlie', 'Diana'],
    'city': ['New York', 'Los Angeles', 'Chicago', 'Houston']
}

# Create a DataFrame from the dictionary
df_requested_data = pd.DataFrame(data)

# Convert the DataFrame to CSV format as a string
csv_output = df_requested_data.to_csv(index=False)

# Display the CSV output
print(csv_output)

#Handling null values

df_requested_data.shape

df_requested_data.isnull().sum()

#fillna(value)

# This line caused an error because 'COMMISION_DCT' column does not exist.
# df['COMMISION_DCT'].fillna()

# Example of using fillna on an existing column (e.g., 'city')
# In this case, there are no null values in 'city', but this shows the correct syntax.
# Updated to avoid FutureWarning by not using inplace=True directly on a Series view.
df['city'] = df['city'].fillna('Unknown')
print(df)

import numpy as np

# Add a new column 'Department_ID' with some missing values for demonstration
df['Department_ID'] = [101, 102, np.nan, 103] # Example with a missing value

# Now, apply fillna to the 'Department_ID' column, assigning the result back
df['Department_ID'] = df['Department_ID'].fillna(0)
print(df)

df.dropna() #null row ko record hatxa

"""fill data with mean, median, and mode"""

import numpy as np

# Reintroduce some missing values in 'Department_ID' for demonstration
df['Department_ID'] = [101, 102, np.nan, 103]

# Calculate the mean of 'Department_ID'
mean_department_id = df['Department_ID'].mean()

# Fill missing values in 'Department_ID' with its mean
df['Department_ID'] = df['Department_ID'].fillna(mean_department_id)

print(df)

import numpy as np

# Reintroduce some missing values and duplicate values in 'Department_ID' for demonstration
df['Department_ID'] = [101, 102, np.nan, 102]

# Calculate the mode of 'Department_ID'
# .mode()[0] is used to get the first mode in case there are multiple modes
mode_department_id = df['Department_ID'].mode()[0]

print(f"The mode of 'Department_ID' is: {mode_department_id}")

mode_dep = df['Department_ID'].mode()

df.isnull().sum()

"""Group By"""

'''
 Aggregate function
......................
mean
max
min
count
sum
'''

# find total  no of emplyess according to its department

emp_dep = df.groupby('Department_ID')

emp_dep = df.groupby('Department_ID')['employee_id'].count().reset_index()

df[['Department_ID', 'employee_id']]

emp_dep

# find total salary of employess according to JOB_ID

# The original code caused an error because 'JOB_ID' and 'SALARY' columns do not exist.
# To demonstrate grouping with existing columns, we will group by 'Department_ID' and count 'employee_id's.
# If you need 'JOB_ID' or 'SALARY', you would first need to add those columns to your DataFrame.
job_sal = df.groupby('Department_ID')['employee_id'].count().reset_index()

# Add a 'dob' (Date of Birth) column to the DataFrame
df['dob'] = ['1990-05-15', '1988-11-22', '1992-01-01', '1995-07-30']

# Display 'id' and 'dob' columns
df[['id', 'dob']]

# finding distributed salary

# First, add 'JOB_ID' and 'SALARY' columns for demonstration
df['JOB_ID'] = ['Developer', 'Designer', 'Developer', 'Tester']
df['SALARY'] = [70000, 60000, 75000, 55000]

# Now, perform the groupby operation
job_dep_sal = df.groupby(['Department_ID', 'JOB_ID'])['SALARY'].sum().reset_index()
print(job_dep_sal)

# find total salary, max, min , average salary by department_id

salary_details = df.groupby('Department_ID')['SALARY'].agg(['sum', 'max', 'min', 'mean']).reset_index()
salary_details

